---
Título: All In One Place
Objetivo: Determinar quem são os clientes elegíveis para participar de um programa
  de fidelidade da empresa All In One Place?
Autor: Pedro H. Fusco Nogueira
output: word_document
---

O conjunto de dados:

Cada linha representa uma transação de venda, que ocorreu entre o período de Novembro de 2016 e Dezembro de 2017.

Invoice Number: identificador único de cada transação.
Stock Code Product: código do item.
Description Product: nome do item
Quantity: A quantidade de cada item comprado por transação.
Invoice Date: O dia em que a transação ocorreu
Unit Price: Preço do produto por unidade
Customer ID: identificador único do cliente
Country: O nome do país que o cliente reside


Pacotes:
```{r}
library(tidyverse)
library(ggplot2)
library(lubridate)
library(cluster)
library(dendextend)
library(factoextra)
library(fpc)
library(gridExtra)
library(glue)
```
Dados:
```{r}
dados <- read_csv("Ecommerce.csv")
```

-----------------------------------------------------------------------------------------------------
- Visualização Inicial e limpeza dos dados:

```{r}
head(dados)
```

```{r}
glue("A base de dados tem {dim(dados)[1]} observações (linhas) e {dim(dados)[2]} variáveis (colunas).")
```

- Verificando se existe trasação duplicada:
```{r}
glue("A base de dados possui {length(dados$InvoiceNo)} transações distintas.")
```
Como a base de dados possui o número de colunas igual ao número de transações únicas podemos concluir que não temos observações duplicadas.


- Verificando variáveis:
```{r}
glimpse(dados)
```
A coluna "X9" possui apenas valores faltantes, vamos eliminá-la e também vamos converter a coluna "InvoiceDate" para o formato de data.
 
```{r}
dados$X9 <- NULL
dados$InvoiceDate <- dmy(dados$InvoiceDate)
```


- Verificando valores das variáveis:
```{r}
summary(dados)
```
Na coluna CustomerID (identificador único do cliente) existem muitos valores faltantes. Não existe maneira de usar esses clientes em um programa de fidelidade da empresa, pois não temos como saber quem eles são. Vamos excluir as observações que possuem compras feitas por clientes sem identificação.
```{r}
dados <- drop_na(dados)
summary(dados)
```
Excluindo os compradores não identificados os Preço do produto por unidade (UnitPrice) que eram negativos já foram excluidos. Porém, ainda temos números negativos nas quantidades de produto, não temos informações sobre o significado desses valores. Portanto é melhor que esles estejam fora da nossa análise.

```{r}
dados <- dados[dados$Quantity > 0,]
summary(dados)
```

Temos ainda produtos com o preço por unidade (UnitPrice) iguais a zero, provavelmente são brindes dados pela empresa, isso não acrecenta relevância ao nosso propósito. Vamos assumir que um produto deve custar pelo menos $0.01.

```{r}
dados <- dados[dados$UnitPrice >= 0.01,]
summary(dados)
```
Como a empresa não nos informou nada sobre valores outliers, não vamos nos preocupar com isso. A princípio, nada impede que um cliente faça uma compra com grande quantidade ou com valor muito alto. 

Agora que estamos com a base de dados limpa podemos analisar os clientes que são elegiveis para entrar no programa de fidelidade.

-------------------------------------------------------------------------------------------------------------------
Queremos escolher, para integrar o programa de fidelidade, os clientes que mais gastaram e que, ao mesmo tempo, compraram a maior quantidade de produtos. Mas o cliente que mais gastou não é necessariamente o cliente que comprou a maior quantidade de produtos. Por este motivo, a seguir, vamos fazer algumas observações:


Análise visual:

Criando nova coluna com valor total gasto por transação.
```{r}
dados$TotalGasto <- dados$UnitPrice * dados$Quantity
head(dados)
```

Número de transações e número de clientes:
```{r}
glue("A base de dados possui {nrow(dados)} observações e {length(unique(dados$CustomerID))} clientes.")
```

 - Observações sobre os clientes:
```{r}
dados %>% 
  select("CustomerID", "TotalGasto") %>% 
  group_by(CustomerID) %>% 
  summarise(Gasto_Total = sum(TotalGasto)) %>% 
  arrange(desc(Gasto_Total)) %>% 
  head(20) %>%
  ggplot() +
  geom_col(mapping = aes(x = Gasto_Total,
                         y = reorder(as.factor(CustomerID), Gasto_Total))) +
  geom_label(mapping = aes(x = Gasto_Total,
                           y = reorder(as.factor(CustomerID), Gasto_Total),
                           label = Gasto_Total), size = 2.8, label.size = 0.01) +
  labs(title = "20 clientes que mais gastaram",
       x = "Gasto total",
       y = "Identificação do cliente") +
  theme_bw(base_size = 10)
```

```{r}
dados %>% 
  select("CustomerID", "Quantity") %>% 
  group_by(CustomerID) %>% 
  summarise(quantidade = sum(Quantity)) %>% 
  arrange(desc(quantidade)) %>% 
  head(20) %>%
  ggplot() +
  geom_col(mapping = aes(x = quantidade,
                         y = reorder(as.factor(CustomerID), quantidade))) +
  geom_label(mapping = aes(x = quantidade,
                           y = reorder(as.factor(CustomerID), quantidade),
                           label = quantidade), size = 2.8, label.size = 0.01) +
  labs(title = "20 clientes que compraram a maior quantidade de produtos",
       x = "Quantidade",
       y = "Identificação do cliente") +
  theme_bw(base_size = 10)
```
Portanto, como comentado, de fato, os clientes que mais gastaram não são exatamente os clientes que compram a maior quantidade de produtos.


- Observações sobre os produtos:
```{r}
dados %>% 
  select("Description", "Quantity") %>% 
  group_by(Description) %>% 
  summarise(Quantity = sum(Quantity)) %>% 
  arrange(desc(Quantity)) %>% 
  head(20) %>% 
  ggplot() +
  geom_col(mapping = aes(x = Quantity,
                         y = reorder(as.factor(Description), Quantity))) +
  geom_label(mapping = aes(x = Quantity,
                           y = reorder(as.factor(Description), Quantity),
                           label = Quantity), size = 2.8, label.size = 0.01) +
  labs(title = "20 produtos mais vendidos",
       x = "Quantidade",
       y = "Produtos") +
  theme_bw(base_size = 10)
  
```
```{r}
dados %>% 
  select("Description", "TotalGasto") %>%
  group_by(Description) %>% 
  summarise(maior_lucro = sum(TotalGasto)) %>% 
  arrange(desc(maior_lucro)) %>% 
  head(20) %>% 
  ggplot() +
  geom_col(mapping = aes(x = maior_lucro,
                         y = reorder(as.factor(Description), maior_lucro))) +
  geom_label(mapping = aes(x = maior_lucro,
                           y = reorder(as.factor(Description), maior_lucro),
                           label = maior_lucro), size = 2.8, label.size = 0.01) +
  labs(title = "20 produtos que mais geram lucro",
       x = "Lucro total",
       y = "Produto") +
  theme_bw(base_size = 10)
```
Podemos ver que nem todos os produtos que mais venderam são os mesmos que geraram maior ganho para a empresa.


- Observações sobre os paises:
```{r}
dados %>% 
  select("Country", "TotalGasto") %>% 
  group_by(Country) %>% 
  summarise(gasto_pais = sum(TotalGasto)) %>% 
  arrange(desc(gasto_pais)) %>%
  head(20) %>% 
  ggplot() +
  geom_col(mapping = aes(x = gasto_pais,
                         y = reorder(as.factor(Country), gasto_pais))) +
  geom_label(mapping = aes(x = gasto_pais,
                           y = reorder(as.factor(Country), gasto_pais),
                           label = gasto_pais), size = 2.8, label.size = 0.01) +
  labs(title = "20 paises que mais geram lucro",
       x = "Lucro total",
       y = "País") +
  theme_bw(base_size = 10)
```
```{r}
dados %>% 
  select("Country", "Quantity") %>% 
  group_by(Country) %>% 
  summarise(compra_pais = sum(Quantity)) %>% 
  arrange(desc(compra_pais)) %>%
  head(20) %>% 
  ggplot() +
  geom_col(mapping = aes(x = compra_pais,
                         y = reorder(as.factor(Country), compra_pais))) +
  geom_label(mapping = aes(x = compra_pais,
                           y = reorder(as.factor(Country), compra_pais),
                           label = compra_pais), size = 2.8, label.size = 0.01) +
  labs(title = "20 paises que compram maior quantidade de produtos",
       x = "Lucro total",
       y = "País") +
  theme_bw(base_size = 10)
```
Neste caso os paises que mais compram são os mesmos que geram mais lucro. Além disso, em proporção, quase a totalidade dos clientes estão no Reino Unido.

Portanto, para selecionarmos os clientes que devem integrar o programa de fidelidade, vamos usar as informações de gasto total por cliente e de quantidade total de produtos comprados. 
Para selecionar os clientes iremos usar a técnica de clusterização.

-------------------------------------------------------------------------------------------
 - Clusterização:

- Preparando dados:
```{r}
dados$CustomerID <- as.factor(dados$CustomerID)

dados_cluster <- dados %>% 
  select("CustomerID", "Quantity", "TotalGasto") %>% 
  group_by(CustomerID) %>% 
  summarise(total_produtos = sum(Quantity),
            total_gasto = sum(TotalGasto))

dados_cluster <- dados_cluster %>% 
  column_to_rownames("CustomerID")

dados_cluster_padronizado <- scale(dados_cluster)
head(dados_cluster_padronizado, 5)
```

- Vamos comparar três métodos de clusterização: clusterização hierárquica, k-Means e DBScan.


1-) Método Hierárquico

Veremos o número ideal da clusters, para isso vamos o método de silhueta.

```{r}
fviz_nbclust(dados_cluster_padronizado, FUNcluster = hcut, method = "silhouette") +
  labs(title = "Número ideal de clusters",
       x = "Número clusters",
       y = "Valor médio da silhueta")
```
O método silhouette indica que 2 clusters é suficiente para uma boa divisão. 

Para selecionar os clusters vamos optar pela distância euclidiana e pelo método de Ward.
```{r}
d <- dist(dados_cluster_padronizado, method = "euclidean")
hc <- hclust(d, method = "ward.D" )
plot(hc, cex = 0.6, hang = -1)
rect.hclust(hc, k = 2)
```

Preparando os dados para visualização dos clusters:
```{r}
cluster_hierarquico <- cutree(hc, k = 2)
clientes_hierarquico <- cbind(dados_cluster, cluster_hierarquico)
head(clientes_hierarquico)
```
```{r}
glue("O primeiro cluster possui {nrow(clientes_hierarquico[clientes_hierarquico$cluster == 1, ])} clientes e o segundo possui {nrow(clientes_hierarquico[clientes_hierarquico$cluster == 2, ])} clientes")
```
- Visualização dos clientes po cluster:
```{r}
ggplot(clientes_hierarquico) +
  geom_point(mapping = aes(x = total_produtos, y = total_gasto,
                           color = as.factor(cluster_hierarquico))) +
  labs(title = "Clusters pelo método hierárquico",
       x = "Quantidade de produtos",
       y = "Total gasto",
       color = "Clusters") +
  theme_bw()
```
Vemos que o cluster 1 é o grupo de clientes que realizaram o maior número de compras de produtos e gastaram mais. Este é o grupo que vamos escolher.

```{r}
nomes_hierarquico <- row.names(clientes_hierarquico[clientes_hierarquico$cluster == 1,])

fidelidade_hierarquico = dados %>% 
  filter(CustomerID %in% nomes_hierarquico)

head(fidelidade_hierarquico, 5)
```

```{r}
glue("Foram selecionados {length(unique(fidelidade_hierarquico$CustomerID))} clientes que fizeram {nrow(fidelidade_hierarquico)} transações.")
```

```{r}
glue("A porcentagem de clientes selecionados, em relação ao total de clientes, é de {round(length(unique(fidelidade_hierarquico$CustomerID))/length(unique(dados$CustomerID)) * 100, 2)}%")
```

- Comparando os gastos e a quantidade de compra de produtos dos clientes selecionados com todos os clientes.
```{r}
h_gastos_perc <- round(sum(fidelidade_hierarquico$TotalGasto)/sum(dados$TotalGasto)*100, 2)
h_quantidade_perc <- round(sum(fidelidade_hierarquico$Quantity)/sum(dados$Quantity)*100, 2)

glue("Porcentagem de gasto dos clientes selecionados corresponde a {h_gastos_perc}% do total e a porcentagem de produtos comprados corresponde a  {h_quantidade_perc}% do total.")
```

-----------------------------||-------------------------------
2-) Método k-means:

Número ideal de clusters:
```{r}
fviz_nbclust(dados_cluster_padronizado, FUNcluster = kmeans, method = "silhouette") +
  labs(title = "Número ideal de clusters",
       x = "Número clusters",
       y = "Valor médio da silhueta")
```
- Novamente vamos escolher, de acordo com a média de silhueta, 2 clusters.
```{r}
cluster_kmeans <- kmeans(dados_cluster_padronizado, centers = 2)
fviz_cluster(cluster_kmeans, geom = "point", data = dados_cluster_padronizado) +
  labs(title = "Clusters pelo método kmeans com 2 centros")

```
Nesta primeira visualização o cluster 1 parece ser o que nos interessa.

- Organizando os grupos em um dataframe:
```{r}
cluster_kmeans <- data.frame(cluster_kmeans$cluster)
clientes_kmeans <- cbind(dados_cluster, cluster_kmeans)
head(clientes_kmeans)
```
```{r}
glue("Foram selecionados {nrow(clientes_kmeans[clientes_kmeans$cluster_kmeans.cluster == 1, ])} clientes no cluster 1 e {nrow(clientes_kmeans[clientes_kmeans$cluster_kmeans.cluster == 2, ])} clientes no cluster 2.")
```

Vamos visualizar os clusters.
```{r}
ggplot(clientes_kmeans) +
  geom_point(mapping = aes(x = total_produtos, y = total_gasto, 
                    color = as.factor(cluster_kmeans.cluster))) +
  labs(title = "Clusters pelo método K-Means",
       x = "Quantidade de produtos",
       y = "Total gasto",
       color = "Clusters") +
  theme_bw()
```
A visualização acima confirma que o cluster 1 é onde estão os clientes que mais compraram e que mais gastaram.


```{r}
nomes_kmeans <- c(row.names(clientes_kmeans[clientes_kmeans$cluster_kmeans.cluster == 1,]))
fidelidade_kmeans <- dados %>% 
  filter(dados$CustomerID %in% nomes_kmeans)
fidelidade_kmeans
```
```{r}
glue("Ficamos com {nrow(fidelidade_kmeans)} observações e {length(unique(fidelidade_kmeans$CustomerID))} clientes.")
```

Porcentagem de clientes selecionados:
```{r}
glue("A porcentagem de clientes selecionados foi de {round(length(unique(fidelidade_kmeans$CustomerID))/length(unique(dados$CustomerID))*100, 2)}%")
```

- Comparando os gastos e a quantidade de compra de produtos dos clientes selecionados com todos os clientes.
```{r}
k_gastos_perc <- round(sum(fidelidade_kmeans$TotalGasto)/sum(dados$TotalGasto)*100, 2)
k_quantidade_perc <- round(sum(fidelidade_kmeans$Quantity)/sum(dados$Quantity)*100, 2)

glue("Os gastos dos clientes selecionados pelo k-means correspondem a {k_gastos_perc}% do total e a porcentagem de produtos comprados a {k_quantidade_perc}% do total")
```
O método k-means acabou selecionando poucos clientes para o programa de fidelidade. O ponto bom disto é que o programa seria de pouco custo para a empresa, porém atingiria um número muito pequeno de clientes. Além disto, os clientes selecionados são responsáveis por poucas compras e pouco gasto em comparação com aqueles selecionados pelo método hierárquico.

-----------------------------------||--------------------------------
3-)Método DBScan


```{r}
dbscan <- dbscan(dados_cluster_padronizado,eps = 0.5, MinPts = 5)

clientes_dbscan <- dados_cluster
clientes_dbscan$dbscan <- dbscan$cluster

unique(clientes_dbscan$dbscan)
```
O método dbscan selecionou também selecionou 2 clusters. Vamos observa-los.
```{r}
head(clientes_dbscan)
```



```{r}
ggplot(clientes_dbscan) +
   geom_point(mapping = aes(x = total_produtos, y = total_gasto,
              color = as.factor(dbscan))) +
  labs(title = "Clusters pelo método DBScan",
       x = "Quantidade de produtos",
       y = "Total gasto",
       color = "Clusters") +
  theme_bw()
```
Aqui, o cluster em que estão os clientes de nosso interesse é o cluster 0.

```{r}
nomes_dbscan <- row.names(clientes_dbscan[clientes_dbscan$dbscan == 0,])

fidelidade_dbscan = dados %>% 
  filter(CustomerID %in% nomes_dbscan)

head(fidelidade_dbscan, 5)
```

```{r}
glue("O número de observações selecionadas foi de {nrow(fidelidade_dbscan)} e de clientes foi {length(unique(fidelidade_dbscan$CustomerID))}.")
```

```{r}
glue("Porcentagem de clientes selecionados foi de {round(length(unique(fidelidade_hierarquico$CustomerID))/length(unique(dados$CustomerID)) * 100, 2)}%")
```

Comparando os gastos e a quantidade de compra de produtos dos clientes selecionados com todos os clientes.
```{r}
db_gastos_perc <- round(sum(fidelidade_dbscan$TotalGasto)/sum(dados$TotalGasto)*100, 2)
db_quantidade_perc <- round(sum(fidelidade_dbscan$Quantity)/sum(dados$Quantity)*100, 2)

glue("Os clientes selecionados aqui são responsáveis por {db_gastos_perc}% dos ganhos da empresa e por Porcentagem de produtos: {db_quantidade_perc}% dos produtos vendidos.")
```

Os resultados do método DBScan estão muito próximo dos resultados atingidos pelo método hierárquico.


---------------------------------------------------------------------------------------------------------
Sumarizando:

Os métodos que fizeram as melhores seleções foram o DBScan e o método hierárquico.

- Método DBScan: 0.92% (41) de clientes, 31.11% do ganho total e 30.73% dos produtos comprados.

- Método hieráquico: 0.92% (40) de clientes, 31.03% do ganho total e 30.39% dos produtos comprados.

Comparando os clientes escolhidos:
```{r}
sum(unique(fidelidade_dbscan$CustomerID) %in% unique(fidelidade_hierarquico$CustomerID))
```
Os clientes escolhidos pelos dois métodos são os mesmos, com a exceção de um cliente a mais no método dbscan.

Porcentagem de lucro por cliente:
```{r}
glue("No método DBScan, em média, cada cliente gerou {round(31.11/41, 2)}% dos gastos, já no método hierarquico cada cliente corresponde a {round(31.03/40, 2)}% dos ganhos")
```
Portanto, mesmo a diferença sendo muito pequena, vamos optar pela escolha do método hierárquico. 
```{r}
unique(fidelidade_hierarquico$CustomerID)
```


Conclusão:


As pessoas elegíveis para participar do programa de fidelidade da empresa All In One são:
```{r}
unique(fidelidade_hierarquico$CustomerID)
```
São 40 clientes, aproximadamente 1% de toda a clientela, esses tem como característica os maiores compras na empresa, tanto em quantidade de produto quanto em quantidade de dinheiro. Os clientes escolhidos são responsáveis por 31,03% de todo o ganho financeiro da empresa e também por 30.39% da quantidade de produtos vendidos. Espera-se que com o início do programa de fidelidade a quantidade de faturamento da empresa aumente, não só com os clientes escolhidos nesse momento, mas também com clientes que podem acabar sendo aderidos no programa. 

O time de marketing pode realizar ações para popularizar o programa de fidelidade, principalmente para países fora do Reino Unido, de forma que novos clientes se sintam incentivados a comprar mais na empresa com a finalidade de serem incluidos no programa.
---------------------------------------------------------------------------------------------------------
